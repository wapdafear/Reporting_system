<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <title id="title">ShipStation Orders & Shipments Analysis</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 50;
            padding: 500;
            padding-top: 100;
            background-color: #353333;
        }
        .container {
            max-width: 2000px;
            background: rgb(11, 5, 31);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        .heading {
            margin: auto;
            width: 100%;
            padding-top: 1%;
            text-align: center;
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            padding: 20px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            z-index: 101;
        }
        .heading:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        header {
            background: #007BFF;
            color: white;
            padding: 1rem;
            text-align: center;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        table th, table td {
            padding: 0.75rem;
            border: 1px solid #ddd;
            text-align: left;
        }
        table th {
            color: rgb(58, 228, 32);
            font-size: 20px;
            font-weight: bolder;
            text-decoration: underline;
        }
        .filters {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            color: rgb(57, 1, 1);
        }
        select {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #4CAF50;
            border-radius: 5px;
        }
        input[type="checkbox"]:hover {
            transform: scale(1.2);
            transition: 0.2s ease-in-out;
        }
        #select-all {
            width: 22px;
            height: 22px;
            accent-color: #ffcc00;
            border-radius: 3px;
        }
        tr.selected {
            background-color: rgba(0, 128, 0, 0.3) !important;
            transition: 0.2s ease-in-out;
        }
        .table-dark input[type="checkbox"] {
            filter: brightness(1.5);
        }
        table td {
            border-radius: 0px;
            text-align: center;
            padding: 0.75rem;
            border: 1px solid #ddd;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        table td:hover {
            border-color: #007bff;
        }
        /* Green text for columns 5 and onward in orders table (SKU, Description, Selling Price, Customer Paid Shipping, Label Cost) */
        table#orders-table td:nth-child(n+5) {
            color: #5cc46b !important;
            font-weight: 500 !important;
            font-size: larger;
        }
        
        /* Group styling for different column types */
        
        /* Order information columns (1-4: Store, Order Number, Order Status, Order Date) */
        table#orders-table td:nth-child(-n+4) {
            color: #a6c0fe !important;
            font-weight: 500 !important;
        }
        
        /* Make SKU, Manufacturer, Description, and Images columns blue */
        table#orders-table td:nth-child(5), /* SKU */
        table#orders-table td:nth-child(6), /* Manufacturer */
        table#orders-table td:nth-child(7), /* Images */
        table#orders-table td:nth-child(8) /* Description */ {
            color: #a6c0fe !important;
            font-weight: 500 !important;
            font-size: larger;
        }
        
        /* Make cost-related columns light purple */
        table#orders-table td:nth-child(10), /* Cost Price */
        table#orders-table td:nth-child(11), /* Quantity */
        table#orders-table td:nth-child(12), /* Platform Fee */
        table#orders-table td:nth-child(13), /* Cost W/ Quantity */
        table#orders-table td:nth-child(14), /* Label Cost */
        table#orders-table td:nth-child(15), /* Total Cost */
        table#orders-table td:nth-child(17) /* Heavy Shipping */ {
            color: #d8b5ff !important;
            font-weight: 500 !important;
            font-size: larger;
        }
        
        /* Highlight the most important columns - Selling Price and P/L */
        table#orders-table td:nth-child(9), /* Selling Price */
        table#orders-table td:nth-child(16) /* P/L */ {
            color: #3fe77b !important;
            font-weight: bold !important;
            font-size: larger;
            /* Removed background color as requested */
        }
        
        /* Update column header styling to match */
        /* Order information headers (1-4) */
        table#orders-table th:nth-child(-n+4) {
            color: #a6c0fe !important;
        }
        
        /* SKU, Manufacturer, Description, and Images headers */
        table#orders-table th:nth-child(5), /* SKU */
        table#orders-table th:nth-child(6), /* Manufacturer */
        table#orders-table th:nth-child(7), /* Images */
        table#orders-table th:nth-child(8) /* Description */ {
            color: #a6c0fe !important;
        }
        
        /* Cost-related column headers */
        table#orders-table th:nth-child(10), /* Cost Price */
        table#orders-table th:nth-child(11), /* Quantity */
        table#orders-table th:nth-child(12), /* Platform Fee */
        table#orders-table th:nth-child(13), /* Cost W/ Quantity */
        table#orders-table th:nth-child(14), /* Label Cost */
        table#orders-table th:nth-child(15), /* Total Cost */
        table#orders-table th:nth-child(17) /* Heavy Shipping */ {
            color: #d8b5ff !important;
        }
        
        /* Important column headers - Selling Price and P/L */
        table#orders-table th:nth-child(9), /* Selling Price */
        table#orders-table th:nth-child(16) /* P/L */ {
            color: #3fe77b !important;
            text-decoration: underline overline;
        }
        
        /* REMOVED: table-with-filters class */
        
        /* RESTORED: original table margins */
        #orders-table {
            margin-top: 1rem;
            border-collapse: separate;
            border-spacing: 0;
            background-color: #1d1d1d;
        }

        /* Reset all table styling first */
        #orders-table {
            border-collapse: separate !important;
            border-spacing: 0 !important;
        }

        /* Force table to use row borders correctly */
        .table.table-dark.table-striped.table-hover tbody tr {
            border-width: 0 !important;
        }

        /* Updated order group styles with bigger, brighter borders on all sides */
        .table-dark tbody tr.order-group {
            display: table-row !important;
            border-width: 0 !important; 
            position: relative !important;
            background: transparent !important;
            transition: none !important;
            --bs-table-accent-bg: inherit !important;
            box-shadow: none !important;
        }

        .table-dark tbody tr.order-group:hover {
            background: inherit !important;
        }

        .table-dark tbody tr.order-group td {
            border: 2px solid #3498db !important; /* Bright blue borders on all cells */
        }

        .table-dark tbody tr.order-group.first-item {
            border-top-left-radius: 10px !important;
            border-top-right-radius: 10px !important;
        }

        .table-dark tbody tr.order-group.first-item td:first-child {
            border-top-left-radius: 8px !important;
        }

        .table-dark tbody tr.order-group.first-item td:last-child {
            border-top-right-radius: 8px !important;
        }

        .table-dark tbody tr.order-group.last-item {
            margin-bottom: 12px !important;
            border-bottom-left-radius: 10px !important;
            border-bottom-right-radius: 10px !important;
        }

        .table-dark tbody tr.order-group.last-item td:first-child {
            border-bottom-left-radius: 8px !important;
        }

        .table-dark tbody tr.order-group.last-item td:last-child {
            border-bottom-right-radius: 8px !important;
        }

        /* Fix adjoining cells to not have double borders */
        .table-dark tbody tr.order-group:not(.first-item) td {
            border-top: none !important;
        }

        .table-dark tbody tr.order-group:not(.last-item) td {
            border-bottom: none !important;
        }

        /* Remove the item count badge that appears at the top of multi-item orders */
        .table-dark tbody tr.order-group .item-count {
            display: inline-block !important; /* Show the badge again */
            position: absolute;
            top: -10px;
            left: 35px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            line-height: 22px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        /* Repeated order info in multi-item orders will be less visible */
        .table-dark tbody tr.order-group:not(.first-item) td:nth-child(1),
        .table-dark tbody tr.order-group:not(.first-item) td:nth-child(2),
        .table-dark tbody tr.order-group:not(.first-item) td:nth-child(3),
        .table-dark tbody tr.order-group:not(.first-item) td:nth-child(4),
        .table-dark tbody tr.order-group:not(.first-item) td:nth-child(5) {
            opacity: 1 !important;
        }

        /* Direct styling for td elements to ensure borders are visible */
        .table-dark tbody tr.order-group td {
            background-color: transparent !important;
        }
        
        /* Green text for columns 2 and onward in shipments table (Label Cost) */
        table#shipments-table td:nth-child(n+2) {
            color: #5cc46b !important;
            font-weight: 500 !important;
            font-size: larger;
        }
        
        /* Highlight label cost column */
        table#orders-table td:nth-child(11) {
            background-color: transparent;
            color: #ffcc00 !important;
            font-weight: bold !important;
        }
        
        /* Visualization container */
        .visualization {
            margin-top: 20px;
            padding: 15px;
            background-color: #222;
            border-radius: 10px;
            height: 400px; /* Set explicit height */
            position: relative;
        }
        
        /* Fix for chart canvas */
        #profit-chart {
            width: 100% !important;
            height: 300px !important;
            margin-top: 15px;
        }
        
        /* Loading indicator */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            color: white;
            font-size: 1.2rem;
        }
        .loading:after {
            content: " .";
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { content: " ."; }
            40% { content: " .."; }
            60% { content: " ..."; }
            80%, 100% { content: " ...."; }
        }
        
        /* Controls container */
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 15px; /* Restore margin */
            padding: 15px;
            background-color: rgb(11, 5, 31);
            border-radius: 10px; /* Restore full border radius */
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); /* Restore shadow */
            width: 100%;
        }
        
        /* Filter group */
        .filter-group {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Buttons container for better alignment */
        .buttons-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            margin-top: auto;
        }
        
        .filter-group label {
            color: white;
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 5px;
        }
        
        /* Custom select styling */
        .custom-select {
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            font-size: 14px;
            width: 100%;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .custom-select:hover {
            background-color: #444;
            border-color: #666;
        }
        
        /* Date inputs */
        .date-input {
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #444;
            background-color: #333;
            color: white;
            width: 100%;
        }
        
        /* Action button */
        .action-btn {
            padding: 10px 20px;
            background: linear-gradient(90deg, #6a11cb, #2575fc);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            align-self: flex-end;
            margin-top: auto;
        }
        
        .action-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* Store badge */
        .store-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .store-badge.amazon {
            background-color: #FF9900;
            color: #000;
        }
        
        .store-badge.ebay {
            background-color: #e53238;
            color: white;
        }
        
        .store-badge.shopify {
            background-color: #96bf48;
            color: white;
        }
        
        .store-badge.walmart {
            background-color: #0071ce;
            color: white;
        }
        
        /* Product image styling */
        .product-image {
            width: 90px;
            height: 90px;
            object-fit: contain;
            background-color: transparent;
            border-radius: 8px;
            transition: transform 0.2s;
        }
        
        .product-image:hover {
            transform: scale(1.5);
            z-index: 100;
        }
        
        /* Statistics cards */
        .stats-container {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            flex: 1;
            min-width: 200px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
            color: #5cc46b;
        }
        
        .stat-title {
            font-size: 14px;
            color: #999;
            margin-bottom: 5px;
        }
        
        /* Make table headers sticky */
        thead {
            background-color: #1d1d1d;
            width: 100%;
            display: table-header-group;
        }
        
        thead tr {
            background-color: #1d1d1d;
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.6);
        }
        
        thead th {
            background-color: #1d1d1d;
            border-bottom: 2px solid #333;
        }
        
        /* Multi-label order styling */
        tr.multi-label-group {
            background-color: rgba(52, 152, 219, 0.05) !important;
        }
        
        tr.multi-label-parent {
            border-top: 2px solid #3498db;
        }
        
        tr.multi-label-child {
            border-top: 1px dashed #3498db;
        }
        
        /* Badge styling */
        .badge {
            padding: 3px 6px;
            font-size: 10px;
            border-radius: 3px;
        }
        
        .bg-info {
            background-color: #17a2b8;
        }
        
        .bg-secondary {
            background-color: #6c757d;
        }
    </style>
</head>
<body>
    <H1 class="heading">ShipStation Orders & Shipments Analysis</H1>
    
    <div class="stats-container">
        <div class="stat-card">
            <div class="stat-title">Total Orders</div>
            <div class="stat-value" id="total-orders">0</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Total Sales</div>
            <div class="stat-value" id="total-sales">$0.00</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Total Profit</div>
            <div class="stat-value" id="total-profit">$0.00</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Average Profit</div>
            <div class="stat-value" id="avg-profit">$0.00</div>
        </div>
    </div>
    
    <div class="controls-container">
        <div class="filter-group">
            <label for="store-filter">Store Filter</label>
            <select id="store-filter" class="custom-select">
                <option value="all">All Stores</option>
                <option value="373980" selected>SurgiMac Amazon Store</option>
                <option value="498468">SurgiMac Ebay Store</option>
                <option value="470756">DD eBay Store</option>
                <option value="428642">Dental District</option>
                <option value="331737">Manual Orders</option>
                <option value="452424">Network</option>
                <option value="498364">New Walmart Store</option>
                <option value="498515">Supply District</option>
                <option value="494346">SurgiMac Store</option>
            </select>
        </div>
        
        <div class="filter-group">
            <label for="status-filter">Order Status</label>
            <select id="status-filter" class="custom-select">
                <option value="all">All Statuses</option>
                <option value="shipped" selected>Shipped Only</option>
                <option value="awaiting_shipment">Awaiting Shipment</option>
                <option value="on_hold">On Hold</option>
                <option value="cancelled">Cancelled</option>
            </select>
        </div>
        
        <div class="filter-group">
            <label for="brand-filter">Brand Filter</label>
            <select id="brand-filter" class="custom-select">
                <option value="all">All Brands</option>
                <!-- Will be populated dynamically -->
            </select>
        </div>
        
        <div class="filter-group">
            <label>Order Type</label>
            <div style="display: flex; align-items: center; margin-top: 5px;">
                <input type="checkbox" id="multi-item-filter" style="width: 20px; height: 20px; margin-right: 10px;">
                <label for="multi-item-filter" style="color: white; margin: 0;">Show Multi-Item Orders Only</label>
            </div>
            <div style="display: flex; align-items: center; margin-top: 10px;">
                <input type="checkbox" id="parent-child-filter" style="width: 20px; height: 20px; margin-right: 10px;" title="Filter to show only orders with parent-child relationships or multiple labels">
                <label for="parent-child-filter" style="color: white; margin: 0;">Show Parent-Child/Multi-Label Orders</label>
            </div>
        </div>
        
        <div class="filter-group">
            <label for="date-range">Date Range</label>
            <select id="date-range" class="custom-select">
                <option value="today" selected>Today</option>
                <option value="yesterday">Yesterday</option>
                <option value="last7">Last 7 Days</option>
                <option value="last30">Last 30 Days</option>
                <option value="custom">Custom Range</option>
            </select>
            <div id="date-range-display" style="color: #5cc46b; font-size: 12px; margin-top: 5px; font-style: italic;"></div>
        </div>
        
        <div class="filter-group" id="custom-date-container" style="display:none;">
            <label for="start-date">Custom Date Range</label>
            <input type="date" id="start-date" class="date-input">
            <input type="date" id="end-date" class="date-input" style="margin-top:5px;">
        </div>
        
        <div class="buttons-container">
            <button id="load-data" class="action-btn">Apply Filters</button>
            <button id="export-csv" class="action-btn" style="background: linear-gradient(90deg, #11cb6a, #25fc84); display: flex; align-items: center; justify-content: center; gap: 8px;">
                <i class="fas fa-file-csv"></i> Export to CSV
            </button>
        </div>
    </div>
    
    <div id="loading-indicator" class="loading" style="display:none;">Loading data</div>
    
    <table class="table table-striped table-dark table-hover" id="orders-table">
        <thead>
            <tr>
                <th>Store</th>
                <th>Order Number</th>
                <th>Order Status</th>
                <th>Order Date</th>
                <th>SKU</th>
                <th>Manufacturer</th>
                <th>Images</th>
                <th>Description</th>
                <th>Selling Price ($)</th>
                <th>Cost Price ($)</th>
                <th>Quantity</th>
                <th>Platform Fee</th>
                <th>Cost W/ Quantity</th>
                <th>Label Cost ($)</th>
                <th>Total Cost ($)</th>
                <th>P/L($)</th>
                <th>Heavy Shipping($)</th>
            </tr>
        </thead>
        <tbody id="shipstation-table">
        </tbody>
    </table>

    <!-- Add pagination controls -->
    <div class="pagination-controls" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px; padding: 10px; background-color: #1d1d1d; border-radius: 5px;">
        <div class="pagination-info" style="color: white;">
            Showing <span id="current-range">0-0</span> of <span id="total-count">0</span> orders (<span id="page-info">Page 0/0</span>)
        </div>
        <div class="pagination-buttons" style="display: flex; gap: 10px;">
            <button id="first-page" class="btn btn-sm btn-outline-secondary">First</button>
            <button id="prev-page" class="btn btn-sm btn-outline-secondary">Previous</button>
            <button id="next-page" class="btn btn-sm btn-outline-secondary">Next</button>
            <button id="last-page" class="btn btn-sm btn-outline-secondary">Last</button>
        </div>
        <div class="page-size-control" style="display: flex; align-items: center; gap: 10px;">
            <label for="page-size" style="color: white;">Orders per page:</label>
            <select id="page-size" class="custom-select custom-select-sm" style="width: auto;">
                <option value="50">50</option>
                <option value="100" selected>100</option>
                <option value="200">200</option>
                <option value="500">500</option>
            </select>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Direct Chart.js loading -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script type="module">
        console.log("Script execution starting...");
        
        // Add pagination variables at the top
        let currentPage = 1;
        let ordersPerPage = 100;
        let allFilteredOrders = [];
        
        // Import functions from shipstation-api.js and Brands.js
        import { fetchShipStationOrders, fetchShipStationShipments } from './shipstation-api.js';
        // Remove Brands.js import since we're fetching directly
        
        // First, add enhanced debugging in the DOMContentLoaded event handler
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOM content loaded, initializing...');
            
            // Show loading indicator immediately
            showLoading(true, 'Initializing and loading data');
            
            // Store data loading promises for better coordination
            let productsPromise = null;
            let ordersPromise = null;
            let shipmentsPromise = null;
            
            // Only load data when in viewport
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        observer.disconnect(); // Only load once
                        initializeDataLoading();
                    }
                });
            }, {threshold: 0.1});
            
            // Start observing the table
            const table = document.getElementById('orders-table');
            if (table) {
                observer.observe(table);
            } else {
                // If table not found, initialize immediately
                initializeDataLoading();
            }
            
            function initializeDataLoading() {
                // Step 1: Check if we have cached data first
                const { startDate, endDate } = getDateRange();
                const cacheKey = getCacheKeyForCurrentDateRange();
                
                // Try to load from localStorage first
                let cachedOrdersData = null;
                try {
                    const cachedData = localStorage.getItem(`shipstation_cache_${cacheKey}`);
                    if (cachedData) {
                        cachedOrdersData = JSON.parse(cachedData);
                        console.log(`Loaded ${cachedOrdersData.length} orders from cache`);
                    }
                } catch (e) {
                    console.warn('Error loading from cache:', e);
                }
                
                // If we have cached data, use it immediately
                if (cachedOrdersData && cachedOrdersData.length > 0) {
                    cachedOrders = cachedOrdersData;
                    
                    // Load products and display orders
                    productsPromise = fetchDirectProductsFromAPI()
                        .then(products => {
                            window.cachedProductsData = products;
                            console.log(`Loaded ${products.length} products directly from API`);
                            
                            // Log a few sample products to verify data
                            if (products.length > 0) {
                                console.log('First few products:', products.slice(0, 3));
                            }
                            
                            return populateBrandFilter();
                        })
                        .then(() => {
                            // Display orders from cache immediately
                            displayOrders(cachedOrders);
                            showLoading(false);
                            
                            // Then refresh data in background
                            setTimeout(() => {
                                // Fetch fresh data in background without showing loading
                                fetchFreshDataInBackground(startDate, endDate);
                            }, 2000);
                        })
                        .catch(error => {
                            console.error('Error loading products:', error);
                            showError('Failed to load product data. Please try again.');
                            showLoading(false);
                        });
                } else {
                    // No cache, load everything
                    loadFullData(startDate, endDate);
                }
            }
            
            function loadFullData(startDate, endDate) {
                // Step 1: Initialize brand filter by loading products directly from API instead of using brandsAPI
                productsPromise = fetchDirectProductsFromAPI()
                    .then(products => {
                        window.cachedProductsData = products;
                        console.log(`Loaded ${products.length} products directly from API`);
                        
                        // Log a few sample products to verify data
                        if (products.length > 0) {
                            console.log('First few products:', products.slice(0, 3));
                        }
                        
                        return populateBrandFilter();
                    })
                    .catch(error => {
                        console.error('Error loading products:', error);
                        showError('Failed to load product data. Please try again.');
                        return Promise.resolve(); // Continue the chain despite error
                    });
                
                // Step 3: Fetch orders and shipments in parallel (only after products are loaded)
                productsPromise.then(() => {
                    console.log('Starting to load orders and shipments...');
                    
                    // Load ShipStation orders
                    ordersPromise = fetchShipStationOrders(startDate, endDate)
                        .then(orders => {
                            cachedOrders = orders || [];
                            console.log(`Loaded ${cachedOrders.length} orders`);
                            
                            // Try to cache, but handle quota errors gracefully
                            try {
                                const cacheKey = getCacheKeyForCurrentDateRange();
                                localStorage.setItem(`shipstation_cache_${cacheKey}`, JSON.stringify(orders));
                            } catch (e) {
                                console.warn('Could not cache orders data due to quota limits. This is non-critical.');
                            }
                            
                            return cachedOrders;
                        })
                        .catch(error => {
                            console.error('Error loading orders:', error);
                            showError('Failed to load order data. Please try again.');
                            return [];
                        });
                    
                    // Load ShipStation shipments
                    shipmentsPromise = fetchShipStationShipments(startDate, endDate)
                        .then(shipments => {
                            cachedShipments = shipments || [];
                            console.log(`Loaded ${cachedShipments.length} shipments`);
                            return cachedShipments;
                        })
                        .catch(error => {
                            console.error('Error loading shipments:', error);
                            // Non-critical, can continue without shipments
                            return [];
                        });
                    
                    // Wait for both orders and shipments to finish loading
                    Promise.all([ordersPromise, shipmentsPromise])
                        .then(([orders, shipments]) => {
                            console.log('All data loaded successfully, displaying results...');
                            // Process orders and display when all data is ready
                            if (orders && orders.length > 0) {
                                // Pre-process orders with shipment data for faster filtering later
                                return preprocessOrders(orders, shipments)
                                    .then(processed => {
                                        processedOrders = processed;
                                        displayOrders(orders);
                                    });
                            } else {
                                const tableBody = document.getElementById("shipstation-table");
                                if (tableBody) {
                                    tableBody.innerHTML = `<tr><td colspan="12" style="color:orange;">No orders found for the selected date range</td></tr>`;
                                }
                            }
                        })
                        .finally(() => {
                            showLoading(false);
                        });
                });
            }
            
            // Function to refresh data in background without interrupting user
            function fetchFreshDataInBackground(startDate, endDate) {
                console.log('Refreshing data in background...');
                
                // Only proceed if not currently loading
                if (isLoading) return;
                
                // Load orders in background
                fetchShipStationOrders(startDate, endDate)
                    .then(orders => {
                        if (orders && orders.length > 0) {
                            // Update cache with new data
                            const cacheKey = getCacheKeyForCurrentDateRange();
                            try {
                                localStorage.setItem(`shipstation_cache_${cacheKey}`, JSON.stringify(orders));
                            } catch (e) {
                                console.warn('Could not update cache: ', e);
                            }
                            
                            // Update only if the number of orders has changed
                            if (!cachedOrders || orders.length !== cachedOrders.length) {
                                console.log('Updated data available, refreshing display');
                                cachedOrders = orders;
                                displayOrders(orders);
                            }
                        }
                    })
                    .catch(error => {
                        console.warn('Background refresh failed:', error);
                    });
                
                // Load shipments in background
                fetchShipStationShipments(startDate, endDate)
                    .then(shipments => {
                        if (shipments && shipments.length > 0) {
                            cachedShipments = shipments;
                        }
                    })
                    .catch(error => {
                        console.warn('Background shipments refresh failed:', error);
                    });
            }
        });
        
        // Initialize UI elements
        const dateRangeSelect = document.getElementById('date-range');
        const customDateContainer = document.getElementById('custom-date-container');
        const storeFilter = document.getElementById('store-filter');
        const statusFilter = document.getElementById('status-filter');
        const brandFilter = document.getElementById('brand-filter');
        const multiItemFilter = document.getElementById('multi-item-filter');
        const parentChildFilter = document.getElementById('parent-child-filter');
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');
        
        // Chart reference
        let profitChart = null;
        
        // Flag to track if data is currently being loaded
        let isLoading = false;
        
        // Global variables to store cached data
        let cachedOrders = [];
        let cachedShipments = [];
        let processedOrders = [];
        
        // Show/hide custom date range based on selection
        if (dateRangeSelect) {
            dateRangeSelect.addEventListener('change', function() {
                console.log("Date range changed to:", this.value);
                if (this.value === 'custom') {
                    customDateContainer.style.display = 'flex';
                    
                    // Initialize date inputs with reasonable defaults if empty
                    if (!startDateInput.value) {
                        const defaultStart = new Date();
                        defaultStart.setDate(defaultStart.getDate() - 7); // Default to 7 days ago
                        startDateInput.value = defaultStart.toISOString().split('T')[0];
                    }
                    
                    if (!endDateInput.value) {
                        const defaultEnd = new Date();
                        endDateInput.value = defaultEnd.toISOString().split('T')[0];
                    }
                } else {
                    customDateContainer.style.display = 'none';
                }
            });
        }
        
        // Add listeners for date inputs to trigger reload on change
        if (startDateInput) {
            startDateInput.addEventListener('change', function() {
                console.log("Start date changed to:", this.value);
                // Don't auto-reload on date input change, let user click Apply Filters
            });
        }
        
        if (endDateInput) {
            endDateInput.addEventListener('change', function() {
                console.log("End date changed to:", this.value);
                // Don't auto-reload on date input change, let user click Apply Filters
            });
        }
        
        // Update the event listener for the load button to make sure it reloads data
        const loadDataBtn = document.getElementById('load-data');
        if (loadDataBtn) {
            loadDataBtn.addEventListener('click', function() {
                console.log("Load button clicked - loading data with current filters");
                
                // Clear existing cache to force reload when date range changes
                cachedOrders = [];
                cachedShipments = [];
                
                loadData();
            });
        }
        
        // Function to show loading indicator
        function showLoading(show, message = 'Loading data...') {
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.innerHTML = message;
                loadingIndicator.style.display = show ? 'flex' : 'none';
            }
            // Update global loading state
            isLoading = show;
            
            // Disable/enable load button
            const loadDataBtn = document.getElementById('load-data');
            if (loadDataBtn) {
                loadDataBtn.disabled = show;
                loadDataBtn.innerHTML = show ? 'Loading...' : 'Apply Filters';
            }
        }
        
        // Helper function to determine store type with better error handling
        function getStoreType(order) {
            if (!order) return "452424"; // Default to Network if order is undefined
            
            try {
            // Direct store ID check - most reliable method
            const storeId = order.advancedOptions?.storeId;
            
            // If we have a valid store ID and it's one of our known IDs, use it directly
            if (storeId) {
                const knownIds = ["373980", "498468", "470756", "428642", "331737", "452424", "498364", "498515", "494346"];
                if (knownIds.includes(storeId)) {
                    return storeId;
                }
            }
            
                // Get store name from various possible locations with null checks
                const storeName = (order.storeName || 
                             order.advancedOptions?.storeName || 
                                 order.store?.name || '').toLowerCase();
            
            // Check for marketplace-specific indicators
            if (order.marketplaceId === "ATVPDKIKX0DER" || 
                order.advancedOptions?.source === "amazon" ||
                    storeName.includes("amazon")) {
                return "373980"; // SurgiMac Amazon Store
            } 
            
            if (order.advancedOptions?.source === "ebay" || 
                order.advancedOptions?.channel === "eBay" ||
                    storeName.includes("ebay")) {
                    if (storeName.includes("surgimac")) {
                    return "498468"; // SurgiMac Ebay Store
                    } else if (storeName.includes("dd")) {
                    return "470756"; // DD eBay Store
                } else {
                        return "498468"; // Default eBay store
                }
            } 
            
            if (order.advancedOptions?.source === "walmart" || 
                order.advancedOptions?.channel === "Walmart" ||
                    storeName.includes("walmart")) {
                return "498364"; // New Walmart Store
            } 
            
                if (storeName.includes("dental") || 
                    storeName.includes("district")) {
                return "428642"; // Dental District
            } 
            
                if (storeName.includes("manual")) {
                return "331737"; // Manual Orders
            } 
            
                if (storeName.includes("network")) {
                return "452424"; // Network
            } 
            
                if (storeName.includes("supply") || 
                    storeName.includes("district")) {
                return "498515"; // Supply District
            } 
            
                if (storeName.includes("surgimac")) {
                return "494346"; // SurgiMac Store
            }
            
            // Default to Network if we can't determine
            return "452424";
            } catch (error) {
                console.warn('Error determining store type:', error);
                return "452424"; // Default to Network on error
            }
        }
        
        // Function to create store badges
        function getStoreBadge(storeId) {
            // Default to Network if not handled
            let badge = '<span class="store-badge" style="background-color: #4682b4; color: white;">Network</span>';
            
            switch(storeId) {
                case "373980": // SurgiMac Amazon Store
                    badge = '<span class="store-badge amazon">SurgiMac Amazon</span>';
                    break;
                case "498468": // SurgiMac Ebay Store
                    badge = '<span class="store-badge ebay">SurgiMac eBay</span>';
                    break;
                case "470756": // DD eBay Store
                    badge = '<span class="store-badge" style="background-color: #9370db; color: white;">DD eBay</span>';
                    break;
                case "428642": // Dental District
                    badge = '<span class="store-badge" style="background-color: #3cb371; color: white;">Dental District</span>';
                    break;
                case "331737": // Manual Orders
                    badge = '<span class="store-badge" style="background-color: #20b2aa; color: white;">Manual</span>';
                    break;
                case "452424": // Network
                    badge = '<span class="store-badge" style="background-color: #4682b4; color: white;">Network</span>';
                    break;
                case "498364": // New Walmart Store
                    badge = '<span class="store-badge walmart">Walmart</span>';
                    break;
                case "498515": // Supply District
                    badge = '<span class="store-badge" style="background-color: #ff6347; color: white;">Supply</span>';
                    break;
                case "494346": // SurgiMac Store
                    badge = '<span class="store-badge" style="background-color: #6a5acd; color: white;">SurgiMac</span>';
                    break;
            }
            
            return badge;
        }
        
        // Function to get date range based on selection
        function getDateRange() {
            if (!dateRangeSelect) {
                // If dateRangeSelect doesn't exist, return today's date range
                const today = new Date();
                const startDate = new Date(today);
                startDate.setHours(0, 0, 0, 0);
                const endDate = new Date(today);
                endDate.setHours(23, 59, 59, 999);
                
                return {
                    startDate: startDate.toISOString(),
                    endDate: endDate.toISOString()
                };
            }
            
            const dateRangeValue = dateRangeSelect.value;
            const today = new Date();
            
            let startDate, endDate;
            
            switch(dateRangeValue) {
                case 'today':
                    startDate = new Date(today);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'yesterday':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 1);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setDate(today.getDate() - 1);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'last7':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 7);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'last30':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 30);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'custom':
                    // Ensure the date inputs have values
                    if (!startDateInput.value || !endDateInput.value) {
                        console.warn('Custom date range selected but date inputs are empty. Defaulting to last 7 days.');
                        
                        // Default to last 7 days if inputs are empty
                        startDate = new Date(today);
                        startDate.setDate(today.getDate() - 7);
                        startDate.setHours(0, 0, 0, 0);
                        endDate = new Date(today);
                        endDate.setHours(23, 59, 59, 999);
                        
                        // Update the inputs to reflect the default values
                        startDateInput.value = startDate.toISOString().split('T')[0];
                        endDateInput.value = endDate.toISOString().split('T')[0];
                    } else {
                        // Parse input values
                    startDate = new Date(startDateInput.value);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(endDateInput.value);
                    endDate.setHours(23, 59, 59, 999);
                        
                        // Validate dates
                        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                            console.error('Invalid date input. Using defaults.');
                            startDate = new Date(today);
                            startDate.setDate(today.getDate() - 7);
                            startDate.setHours(0, 0, 0, 0);
                            endDate = new Date(today);
                            endDate.setHours(23, 59, 59, 999);
                        }
                        
                        // Ensure end date is not before start date
                        if (endDate < startDate) {
                            console.warn('End date is before start date. Swapping dates.');
                            const temp = startDate;
                            startDate = endDate;
                            endDate = temp;
                            
                            // Update inputs to reflect the swap
                            startDateInput.value = startDate.toISOString().split('T')[0];
                            endDateInput.value = endDate.toISOString().split('T')[0];
                        }
                    }
                    break;
                default:
                    startDate = new Date(today);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(today);
                    endDate.setHours(23, 59, 59, 999);
            }
            
            // Log the date range for debugging
            console.log(`Date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);
            
            // Update the visual date range display
            updateDateRangeDisplay(startDate, endDate);
            
            return {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString()
            };
        }
        
        // Function to update the date range display with human-readable dates
        function updateDateRangeDisplay(startDate, endDate) {
            const dateRangeDisplay = document.getElementById('date-range-display');
            if (!dateRangeDisplay) return;
            
            const formatDate = (date) => {
                return date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric', 
                    year: 'numeric'
                });
            };
            
            const start = formatDate(startDate);
            const end = formatDate(endDate);
            
            // Display date range
            if (start === end) {
                dateRangeDisplay.textContent = `Showing orders for ${start}`;
            } else {
                dateRangeDisplay.textContent = `Showing orders from ${start} to ${end}`;
            }
        }
        
        // Function to filter orders based on user selections
        function filterOrders(orders) {
            if (!storeFilter || !statusFilter) {
                return orders;
            }
            
            const storeFilterValue = storeFilter.value;
            const orderStatus = statusFilter.value;
            const brandFilterValue = brandFilter ? brandFilter.value : 'all';
            const showMultiItemOnly = multiItemFilter ? multiItemFilter.checked : false;
            
            return orders.filter(order => {
                // Filter by store
                if (storeFilterValue !== 'all') {
                    const orderStoreId = getStoreType(order);
                    if (storeFilterValue !== orderStoreId) {
                        return false;
                    }
                }
                
                // Filter by status
                if (orderStatus !== 'all' && order.orderStatus !== orderStatus) {
                    return false;
                }
                
                // Filter by multi-item
                if (showMultiItemOnly && order.items.length < 2) {
                    return false;
                }
                
                // Filter by brand if needed
                if (brandFilterValue !== 'all') {
                    // Check if any item in the order has the selected brand
                    return order.items.some(item => {
                        const productInfo = findProductCost(item.sku);
                        const brand = productInfo.manufacturer || '';
                        return brand && brand.toLowerCase() === brandFilterValue.toLowerCase();
                    });
                }
                
                return true;
            });
        }

        // Enhanced findProductCost function for direct API data
        function findProductCost(sku) {
            if (!sku) return { manufacturer: 'Unknown', cost_price: 0 };
            
            try {
                // Simple direct lookup in the cached products
                if (!window.cachedProductsData || !Array.isArray(window.cachedProductsData)) {
                    console.warn('Product cache not initialized or invalid:', window.cachedProductsData);
                    return { manufacturer: 'Unknown', cost_price: 0 };
                }

                // Normalize the SKU from ShipStation for comparison
                const skuString = String(sku).trim().toLowerCase();
                
                // 1. First try exact matches
                const exactMatch = window.cachedProductsData.find(p => {
                    if (!p) return false;
                    
                    // Check API data format which uses Sku field (capital S)
                    const apiSku = p.Sku ? String(p.Sku).trim().toLowerCase() : '';
                    return skuString === apiSku;
                });
                
                if (exactMatch) {
                    return {
                        manufacturer: exactMatch.Manufacturer || 'Unknown',
                        cost_price: typeof exactMatch.Cost === 'number' ? exactMatch.Cost : 
                                   (typeof exactMatch.Cost === 'string' ? parseFloat(exactMatch.Cost) : 0)
                    };
                }
                
                // 2. If no exact match, try partial matching as fallback
                const partialMatch = window.cachedProductsData.find(p => {
                    if (!p || !p.Sku) return false;
                    
                    // API data uses Sku field (capital S)
                    const apiSku = String(p.Sku).trim().toLowerCase();
                    
                    return (apiSku.includes(skuString) || skuString.includes(apiSku));
                });
                
                if (partialMatch) {
                    return {
                        manufacturer: partialMatch.Manufacturer || 'Unknown',
                        cost_price: typeof partialMatch.Cost === 'number' ? partialMatch.Cost : 
                                   (typeof partialMatch.Cost === 'string' ? parseFloat(partialMatch.Cost) : 0)
                    };
                }
                
                // No match found
                return { manufacturer: 'Unknown', cost_price: 0 };
            } catch (error) {
                console.error(`Error finding product for ${sku}:`, error);
                return { manufacturer: 'Unknown', cost_price: 0 };
            }
        }
        
        // Function to get label cost from shipments data with improved handling
        function getLabelCost(orderNumber, shipments) {
            if (!shipments || !Array.isArray(shipments)) return 0;
            
            // Special debugging for order 52698997
            const isSpecialOrder = orderNumber === "52698997";
            if (isSpecialOrder) {
                console.log(`DEBUG: Getting label cost for special order ${orderNumber}`);
            }
            
            // Find matching shipment(s) for this order number
            const orderShipments = shipments.filter(shipment => 
                shipment.orderNumber === orderNumber);
            
            if (orderShipments.length === 0) {
                if (isSpecialOrder) {
                    console.log(`WARNING: No shipments found for special order ${orderNumber}`);
                }
                return 0;
            }
            
            // For orders with multiple shipments, sum all shipment costs
            if (orderShipments.length > 1) {
                console.log(`Multi-label order detected: ${orderNumber} has ${orderShipments.length} shipments`);
                let totalCost = 0;
                
                // Loop through all shipments and sum the costs
                orderShipments.forEach((shipment, index) => {
                    const shipmentCost = shipment.shipmentCost || shipment.cost || 0;
                    const cost = typeof shipmentCost === 'string' ? parseFloat(shipmentCost) || 0 : (shipmentCost || 0);
                    totalCost += cost;
                    console.log(`Shipment ${index+1} for ${orderNumber}: Cost = $${cost.toFixed(2)}`);
                });
                
                console.log(`Total label cost for order ${orderNumber}: $${totalCost.toFixed(2)}`);
                return totalCost;
            }
            
            // For single shipment orders
            const shipment = orderShipments[0];
            const cost = shipment.shipmentCost || shipment.cost || 0;
            const finalCost = typeof cost === 'string' ? parseFloat(cost) || 0 : (cost || 0);
            
            if (isSpecialOrder) {
                console.log(`Single shipment found for order ${orderNumber}: Cost = $${finalCost.toFixed(2)}`);
            }
            
            // Parse the cost if it's a string
            return finalCost;
        }
        
        // Function to calculate per-unit shipping costs safely
        function calculatePerUnitShippingCosts(totalLabelCost, totalCustomerPaidShipping, orderTotalQuantity, orderNumber, shipments) {
            // Add detailed debugging for key orders
            const isSpecialOrder = orderNumber === "52698997" || orderNumber === "52703353";
            if (isSpecialOrder) {
                console.log(`===== SHIPPING COST CALCULATION FOR ${orderNumber} =====`);
                console.log(`Input values: totalLabelCost=$${totalLabelCost.toFixed(2)}, totalCustomerPaidShipping=$${totalCustomerPaidShipping.toFixed(2)}, orderTotalQuantity=${orderTotalQuantity}`);
            }
            
            // Ensure we have valid quantities
            if (!orderTotalQuantity || orderTotalQuantity <= 0) {
                orderTotalQuantity = 1; // Default to 1 if invalid
                if (isSpecialOrder) {
                    console.log(`Quantity validation: orderTotalQuantity was invalid, set to 1`);
                }
            }
            
            // STEP 1: First check for multi-label orders (highest priority)
            let isMultiLabelOrder = false;
            
            // Special handling for known multi-label orders
            if (orderNumber === "52698997" || orderNumber === "52703353") {
                console.log(`SPECIAL HANDLING: Order ${orderNumber} is a known multi-label order - FORCE OVERRIDE`);
                isMultiLabelOrder = true;
            }
            
            // Check for multiple shipments
            let orderShipments = [];
            if (shipments && Array.isArray(shipments)) {
                orderShipments = shipments.filter(shipment => shipment.orderNumber === orderNumber);
                if (isSpecialOrder) {
                    console.log(`Found ${orderShipments.length} shipments for order ${orderNumber}`);
                }
                
                if (orderShipments.length > 1) {
                    isMultiLabelOrder = true;
                    console.log(`Multi-label order detected: ${orderNumber} with ${orderShipments.length} shipments`);
                }
            }
            
            // STEP 2: If it's a multi-label order, use the multi-label calculation logic
            if (isMultiLabelOrder) {
                // For multi-label orders, calculate the per-unit costs by dividing the total by quantity
                const perUnitLabelCost = totalLabelCost / orderTotalQuantity;
                const perUnitCustomerPaidShipping = totalCustomerPaidShipping / orderTotalQuantity;
                
                if (isSpecialOrder) {
                    console.log(`Multi-label order ${orderNumber}: Total Label Cost $${totalLabelCost.toFixed(2)}, Total Quantity ${orderTotalQuantity}, Per Unit Label Cost $${perUnitLabelCost.toFixed(2)}`);
                    console.log(`Multi-label order ${orderNumber}: Total Shipping $${totalCustomerPaidShipping.toFixed(2)}, Total Quantity ${orderTotalQuantity}, Per Unit Shipping $${perUnitCustomerPaidShipping.toFixed(2)}`);
                }
                
                // Return with the multi-label flag set to true
                return {
                    perUnitLabelCost: isFinite(perUnitLabelCost) ? perUnitLabelCost : 0,
                    perUnitCustomerPaidShipping: isFinite(perUnitCustomerPaidShipping) ? perUnitCustomerPaidShipping : 0,
                    isMultiLabelOrder: true
                };
            }
            
            // STEP 3: If not a multi-label order, use the standard calculation
            const perUnitLabelCost = totalLabelCost / orderTotalQuantity;
            const perUnitCustomerPaidShipping = totalCustomerPaidShipping / orderTotalQuantity;
            
            if (isSpecialOrder) {
                console.log(`WARNING: Special order ${orderNumber} was not detected as multi-label!`);
                console.log(`Regular calculation: perUnitLabelCost=$${perUnitLabelCost.toFixed(2)}, perUnitCustomerPaidShipping=$${perUnitCustomerPaidShipping.toFixed(2)}`);
            }
            
            // Ensure we don't return infinity or NaN
            return {
                perUnitLabelCost: isFinite(perUnitLabelCost) ? perUnitLabelCost : 0,
                perUnitCustomerPaidShipping: isFinite(perUnitCustomerPaidShipping) ? perUnitCustomerPaidShipping : 0,
                isMultiLabelOrder: false
            };
        }
        
        // Function to update statistics
        function updateStatistics(orders) {
            let totalSales = 0;
            let totalProfit = 0;
            let totalOrders = 0;
            
            // First, build a map of order numbers to all related orders (for parent-child)
            const relatedOrdersMap = {};
            
            // Group orders by orderNumber to handle parent-child relationships
            orders.forEach(order => {
                const orderNumber = order.orderNumber;
                if (!relatedOrdersMap[orderNumber]) {
                    relatedOrdersMap[orderNumber] = [];
                }
                relatedOrdersMap[orderNumber].push(order);
            });
            
            // Sync shipping data between parent and child orders
            Object.values(relatedOrdersMap).forEach(orderGroup => {
                if (orderGroup.length > 1) {
                    // Find the parent order (usually the first one)
                    const parentOrder = orderGroup.find(order => 
                        order.advancedOptions && order.advancedOptions.mergedIds && 
                        order.advancedOptions.mergedIds.length > 0
                    ) || orderGroup[0];
                    
                    // Get parent shipping amount
                    const parentShippingAmount = parentOrder.shippingAmount || 0;
                    
                    // Distribute parent shipping to all orders in the group
                    orderGroup.forEach(order => {
                        if (order !== parentOrder && (!order.shippingAmount || order.shippingAmount === 0)) {
                            console.log(`Transferring shipping cost from parent order ${parentOrder.orderNumber} to related order ${order.orderNumber}`);
                            order.shippingAmount = parentShippingAmount;
                        }
                    });
                }
            });
            
            // Calculate total quantities per order, including related parent-child orders
            const orderQuantityMap = {};
            
            // Now calculate true total quantity for each order number including parent/child relations
            Object.keys(relatedOrdersMap).forEach(orderNumber => {
                let totalQuantity = 0;
                
                // Sum quantities across all related orders (parent and children)
                relatedOrdersMap[orderNumber].forEach(order => {
                    order.items.forEach(item => {
                        totalQuantity += item.quantity || 1;
                    });
                });
                
                console.log(`Order ${orderNumber} total quantity across all related orders: ${totalQuantity}`);
                orderQuantityMap[orderNumber] = totalQuantity;
            });
            
            // Now process each order using the same calculation logic as in the table display
            for (const order of orders) {
                // Get label cost and customer paid shipping
                const totalLabelCost = getLabelCost(order.orderNumber, cachedShipments || []);
                const totalCustomerPaidShipping = order.shippingAmount || 0;
                
                // Get the total quantity for this order
                const orderTotalQuantity = orderQuantityMap[order.orderNumber] || 1;
                
                // Calculate per unit shipping costs safely
                const { perUnitLabelCost, perUnitCustomerPaidShipping, isMultiLabelOrder } = calculatePerUnitShippingCosts(
                    totalLabelCost,
                    totalCustomerPaidShipping,
                    orderTotalQuantity,
                    order.orderNumber,
                    cachedShipments
                );
                
                // Get store type
                const storeId = getStoreType(order);
                
                // Process each item using the exact same profit calculation as in the table
                for (const item of order.items) {
                    const itemQuantity = item.quantity || 1;
                    const sellingPrice = item.unitPrice * itemQuantity;
                    
                    // Calculate proportional shipping costs
                    let proportionalLabelCost = isMultiLabelOrder ? 
                        (perUnitLabelCost * itemQuantity) : // Use per-unit cost  quantity for both types
                        (perUnitLabelCost * itemQuantity); // Regular calculation
                    
                    let proportionalCustomerPaidShipping = isMultiLabelOrder ?
                        (perUnitCustomerPaidShipping * itemQuantity) : // Use per-unit cost  quantity for both types
                        (perUnitCustomerPaidShipping * itemQuantity); // Regular calculation
                    
                    // Find product cost
                    const productInfo = findProductCost(item.sku);
                    const costPrice = productInfo.cost_price || 0;
                    
                    // Calculate profit exactly as in the table display
                    const feePercentage = getPlatformFeePercentage(storeId);
                    const marketfee = parseFloat((sellingPrice * feePercentage).toFixed(2));
                    const total_cost_with_quantity = parseFloat((costPrice * itemQuantity).toFixed(2));
                    let Total_Cost = total_cost_with_quantity + marketfee + proportionalLabelCost;
                    let profit = (sellingPrice - Total_Cost) + proportionalCustomerPaidShipping;
                    
                    
                    totalSales += sellingPrice;
                    totalProfit += profit;
                    totalOrders++;
                }
            }
            
            // Update stat elements if they exist
            const totalOrdersEl = document.getElementById('total-orders');
            const totalSalesEl = document.getElementById('total-sales');
            const totalProfitEl = document.getElementById('total-profit');
            const avgProfitEl = document.getElementById('avg-profit');
            
            if (totalOrdersEl) totalOrdersEl.textContent = totalOrders;
            if (totalSalesEl) totalSalesEl.textContent = '$' + totalSales.toFixed(2);
            if (totalProfitEl) {
                totalProfitEl.textContent = '$' + totalProfit.toFixed(2);
                totalProfitEl.style.color = totalProfit >= 0 ? '#5cc46b' : '#ff6b6b';
            }
            
            const avgProfit = totalOrders > 0 ? totalProfit / totalOrders : 0;
            if (avgProfitEl) {
                avgProfitEl.textContent = '$' + avgProfit.toFixed(2);
                avgProfitEl.style.color = avgProfit >= 0 ? '#5cc46b' : '#ff6b6b';
            }
        }
        
        // Function to display orders
        function displayOrders(orders) {
            // console.log("Displaying ShipStation Orders data:", orders);
                const tableBody = document.getElementById("shipstation-table");
                if (!tableBody) {
                    console.error("Table body with ID 'shipstation-table' not found.");
                    return;
                }
                tableBody.innerHTML = "";  // Clear previous data

                if (!orders || orders.length === 0) {
                // console.log("No orders data available, showing fallback message");
                tableBody.innerHTML = `<tr><td colspan="12" style="color:red;">No orders data available</td></tr>`;
                updateStatistics([]);
                populateBrandFilter([]); // Update brand filter with empty array
                updatePaginationInfo(0, 0, 0);
                    return;
                }

            // Filter orders based on store, status, and multi-item selections (but not by brand yet)
            const preFilteredOrders = preFilterOrders(orders);
            
            // Now populate brand filter based on pre-filtered orders
            populateBrandFilter(preFilteredOrders);
            
            // Then apply brand filter if needed
            const filteredOrders = applyBrandFilter(preFilteredOrders);
            
            if (filteredOrders.length === 0) {
                tableBody.innerHTML = `<tr><td colspan="12" style="color:orange;">No orders match the selected filters</td></tr>`;
                updateStatistics([]);
                updatePaginationInfo(0, 0, 0);
                return;
            }
            
            // Store filtered orders for pagination
            allFilteredOrders = filteredOrders;

            // Get date range for shipments
            const { startDate, endDate } = getDateRange();
            
            // Use cached shipments or fetch them
            let shipments = cachedShipments;
            if (!shipments || shipments.length === 0) {
                // console.log("No shipments in cache, using 0 for label costs");
                shipments = [];
            }
            
            // Build a map of order numbers to all related orders (for parent-child)
            const relatedOrdersMap = {};
            
            // Group orders by orderNumber to handle parent-child relationships
            filteredOrders.forEach(order => {
                const orderNumber = order.orderNumber;
                if (!relatedOrdersMap[orderNumber]) {
                    relatedOrdersMap[orderNumber] = [];
                }
                relatedOrdersMap[orderNumber].push(order);
            });
            
            // Sync shipping data between parent and child orders
            Object.values(relatedOrdersMap).forEach(orderGroup => {
                if (orderGroup.length > 1) {
                    // Find the parent order (usually the first one)
                    const parentOrder = orderGroup.find(order => 
                        order.advancedOptions && order.advancedOptions.mergedIds && 
                        order.advancedOptions.mergedIds.length > 0
                    ) || orderGroup[0];
                    
                    // Get parent shipping amount
                    const parentShippingAmount = parentOrder.shippingAmount || 0;
                    
                    // Distribute parent shipping to all orders in the group
                    orderGroup.forEach(order => {
                        if (order !== parentOrder && (!order.shippingAmount || order.shippingAmount === 0)) {
                            console.log(`Transferring shipping cost from parent order ${parentOrder.orderNumber} to related order ${order.orderNumber}`);
                            order.shippingAmount = parentShippingAmount;
                        }
                    });
                }
            });
            
            // Calculate total quantities per order, including related parent-child orders
            const orderQuantityMap = {};
            
            // Calculate true total quantity for each order number including parent/child relations
            Object.keys(relatedOrdersMap).forEach(orderNumber => {
                let totalQuantity = 0;
                
                // Sum quantities across all related orders (parent and children)
                relatedOrdersMap[orderNumber].forEach(order => {
                    order.items.forEach(item => {
                        totalQuantity += item.quantity || 1;
                    });
                });
                
                console.log(`Order ${orderNumber} total quantity across all related orders: ${totalQuantity}`);
                orderQuantityMap[orderNumber] = totalQuantity;
            });
            
            // Update statistics with all filtered orders
            updateStatistics(filteredOrders);
            
            // Display the current page
            displayOrdersPage(filteredOrders, orderQuantityMap, shipments);
            
            // Prepare data for chart
            const orderProfits = getAllProfitData(filteredOrders, orderQuantityMap, shipments);
            
            // Draw the chart
            createProfitChart(orderProfits);
        }
        
        // Function to display a specific page of orders
        function displayOrdersPage(orders, orderQuantityMap, shipments) {
            const tableBody = document.getElementById("shipstation-table");
            if (!tableBody) return;
            
            tableBody.innerHTML = ""; // Clear the table
            
            // Calculate pagination
            const totalItems = orders.length;
            const totalPages = Math.ceil(totalItems / ordersPerPage);
            
            // Adjust currentPage if needed
            if (currentPage > totalPages) {
                currentPage = totalPages > 0 ? totalPages : 1;
            }
            
            // Calculate start and end indices
            const startIndex = (currentPage - 1) * ordersPerPage;
            const endIndex = Math.min(startIndex + ordersPerPage, totalItems);
            
            // Update pagination info
            updatePaginationInfo(startIndex, endIndex, totalItems);
            
            // If no orders to display
            if (startIndex >= totalItems) {
                tableBody.innerHTML = `<tr><td colspan="12" style="color:orange;">No orders on this page</td></tr>`;
                return;
            }
            
            // Group orders by orderNumber for multi-label handling
            const orderGroups = {};
            
            // First, group orders by order number
            for (let i = startIndex; i < endIndex; i++) {
                const order = orders[i];
                if (!orderGroups[order.orderNumber]) {
                    orderGroups[order.orderNumber] = [];
                }
                orderGroups[order.orderNumber].push(order);
            }
            
            // Process shipping for parent-child orders
            for (const orderNumber in orderGroups) {
                const orderGroup = orderGroups[orderNumber];
                
                // Only process groups with multiple orders (parent-child)
                if (orderGroup.length > 1) {
                    // Find the parent order (usually the first one)
                    const parentOrder = orderGroup.find(order => 
                        order.advancedOptions && order.advancedOptions.mergedIds && 
                        order.advancedOptions.mergedIds.length > 0
                    ) || orderGroup[0];
                    
                    // Get parent shipping amount
                    const parentShippingAmount = parentOrder.shippingAmount || 0;
                    
                    // Distribute parent shipping to all orders in the group
                    orderGroup.forEach(order => {
                        if (order !== parentOrder && (!order.shippingAmount || order.shippingAmount === 0)) {
                            console.log(`Transferring shipping cost from parent order ${parentOrder.orderNumber} to related order ${order.orderNumber}`);
                            order.shippingAmount = parentShippingAmount;
                        }
                    });
                }
            }
            
            // Display orders for current page
            let orderProfits = [];
            
            // Log for debugging
            console.log("Order quantity map for calculations:", orderQuantityMap);
            
            // Process each order group
            for (const orderNumber in orderGroups) {
                const orderGroup = orderGroups[orderNumber];
                
                // For each order in the group
                for (let i = 0; i < orderGroup.length; i++) {
                    const order = orderGroup[i];
                    
                    // Get store type for display
                    const storeId = getStoreType(order);
                    
                    // Get store badge HTML
                    const storeBadge = getStoreBadge(storeId);
                    
                    // Check if this order has multiple items
                    const isMultiItemOrder = order.items.length > 1;
                    
                    // Get label cost for the order using the shipments data
                    const totalLabelCost = getLabelCost(order.orderNumber, shipments);
                    
                    // Get customer paid shipping amount
                    const totalCustomerPaidShipping = order.shippingAmount || 0;
                    
                    // Get the total quantity for this order for proportional distribution
                    const orderTotalQuantity = orderQuantityMap[order.orderNumber] || 1;
                    
                    // Log for debugging
                    console.log(`Order ${order.orderNumber} using quantity ${orderTotalQuantity} for shipping cost calculations`);
                    console.log(`Order ${order.orderNumber} shipping amount: $${totalCustomerPaidShipping.toFixed(2)}`);
                    
                    // Calculate per unit shipping costs safely
                    const { perUnitLabelCost, perUnitCustomerPaidShipping, isMultiLabelOrder } = calculatePerUnitShippingCosts(
                        totalLabelCost,
                        totalCustomerPaidShipping,
                        orderTotalQuantity,
                        order.orderNumber,
                        cachedShipments
                    );
                    
                    
                    // Process each item in the order
                    for (let itemIndex = 0; itemIndex < order.items.length; itemIndex++) {
                        const item = order.items[itemIndex];
                        const row = document.createElement("tr");
                        const itemQuantity = item.quantity || 1;
                        const sellingPrice = item.unitPrice * itemQuantity;
                        
                        // Calculate proportional shipping costs for this line item
                        // For multi-label orders, don't multiply by quantity again
                        let proportionalLabelCost = isMultiLabelOrder ? 
                            (perUnitLabelCost * itemQuantity) : // Use per-unit cost  quantity for both types
                            (perUnitLabelCost * itemQuantity); // Regular calculation
                        
                        let proportionalCustomerPaidShipping = isMultiLabelOrder ?
                            (perUnitCustomerPaidShipping * itemQuantity) : // Use per-unit cost  quantity for both types
                            (perUnitCustomerPaidShipping * itemQuantity); // Regular calculation
                        
                        // Find product cost and brand
                        const productInfo = findProductCost(item.sku);
                        const costPrice = productInfo.cost_price || 0;
                        const manufacturer = productInfo.manufacturer || 'Unknown';
                        
                        // Calculate profit and other metrics
                        const feePercentage = getPlatformFeePercentage(storeId);
                        const marketfee = parseFloat((sellingPrice * feePercentage).toFixed(2));
                        const feeDisplay = `${(feePercentage * 100).toFixed(0)}%`;
                        const total_cost_with_quantity = parseFloat((costPrice * itemQuantity).toFixed(2));
                        let Total_Cost = total_cost_with_quantity + marketfee + proportionalLabelCost;
                        let profit = (sellingPrice - Total_Cost) + proportionalCustomerPaidShipping;
                        
                        // Special handling for order 52698997
                        if (order.orderNumber === "52698997") {
                            console.log(`Multi-label order ${order.orderNumber}: Item ${item.name}, Quantity ${itemQuantity}, Per Unit Label Cost ${perUnitLabelCost.toFixed(2)}, Proportional Label Cost ${proportionalLabelCost.toFixed(2)}`);
                        }
                        
                        // Add to chart data
                        orderProfits.push({
                            orderNumber: order.orderNumber,
                            profit: profit,
                            store: storeId
                        });
                        
                        // Add classes for multi-item orders
                        if (isMultiItemOrder) {
                            row.classList.add('order-group');
                            if (itemIndex === 0) row.classList.add('first-item');
                            if (itemIndex === order.items.length - 1) row.classList.add('last-item');
                        }
                        
                        // Add class for multi-label parent/child indication when within a group
                        if (orderGroup.length > 1) {
                            row.classList.add('multi-label-group');
                            if (i === 0) {
                                row.classList.add('multi-label-parent');
                            } else {
                                row.classList.add('multi-label-child');
                            }
                        }
                        
                        row.innerHTML = `
                            <td>${isMultiItemOrder && itemIndex > 0 ? '' : storeBadge}${isMultiItemOrder && itemIndex === 0 ? `<span class="item-count">${order.items.length}</span>` : ''}</td>
                            <td>${order.orderNumber || "N/A"}${orderGroup.length > 1 ? (i === 0 ? ' <span class="badge bg-info">Parent</span>' : ' <span class="badge bg-secondary">Child</span>') : ''}</td>
                            <td>${order.orderStatus || "N/A"}</td>
                            <td>${new Date(order.createDate).toLocaleString('en-US', { timeZone: 'America/New_York', year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: true }).replace(',', '') || "N/A"}</td>
                            <td>${item.sku || "N/A"}</td>
                            <td>${manufacturer !== 'Unknown' ? manufacturer : '<span style="color: #ffcc00; font-weight: bold;">Unknown</span>'}</td>
                            <td>${item.imageUrl ? `<img src="${item.imageUrl}" class="product-image" alt="Product Image" loading="lazy">` : "N/A"}</td>
                            <td>${item.name || "N/A"}</td>
                            <td>$${sellingPrice.toFixed(2)}</td>
                            <td>${costPrice > 0 ? `$${costPrice.toFixed(2)}` : '<span style="color: #ff9900; font-weight: bold;">$0.00</span>'}</td>
                            <td>${itemQuantity}</td>
                            <td>$${marketfee.toFixed(2)}</td>
                            <td>$${total_cost_with_quantity.toFixed(2)}</td>
                            <td>$${proportionalLabelCost.toFixed(2)}</td>
                            <td>$${Total_Cost.toFixed(2)}</td>
                            <td style="color: ${profit >= 0 ? '#5cc46b' : '#ff6b6b'} !important;">$${profit.toFixed(2)}</td>
                            <td style="color: ${proportionalCustomerPaidShipping > 0 ? '#ff9900' : 'inherit'} !important; font-weight: ${proportionalCustomerPaidShipping > 0 ? 'bold' : 'normal'};">$${proportionalCustomerPaidShipping.toFixed(2)}</td>
                        `;
                        tableBody.appendChild(row);
                    }
                }
            }
            
            // Create the profit chart with the data
            createProfitChart(orderProfits);
        }
        
        // Function to update pagination information
        function updatePaginationInfo(start, end, total) {
            const currentRangeEl = document.getElementById('current-range');
            const totalCountEl = document.getElementById('total-count');
            const pageInfoEl = document.getElementById('page-info');
            
            if (currentRangeEl && totalCountEl && pageInfoEl) {
                if (total === 0) {
                    currentRangeEl.textContent = '0-0';
                    totalCountEl.textContent = '0';
                    pageInfoEl.textContent = 'Page 0/0';
                } else {
                    currentRangeEl.textContent = `${start + 1}-${end}`;
                    totalCountEl.textContent = total;
                    
                    const totalPages = Math.ceil(total / ordersPerPage);
                    pageInfoEl.textContent = `Page ${currentPage}/${totalPages}`;
                    
                    // Update button states
                    document.getElementById('first-page').disabled = currentPage === 1;
                    document.getElementById('prev-page').disabled = currentPage === 1;
                    document.getElementById('next-page').disabled = currentPage === totalPages;
                    document.getElementById('last-page').disabled = currentPage === totalPages;
                }
            }
        }
        
        // Add event listeners for pagination after DOM is loaded
        window.addEventListener('DOMContentLoaded', function() {
            // ... existing DOMContentLoaded code ...
            
            // Add pagination event listeners
            document.getElementById('first-page')?.addEventListener('click', function() {
                if (currentPage !== 1) {
                    currentPage = 1;
                    displayOrdersPage(allFilteredOrders, getOrderQuantityMap(allFilteredOrders), cachedShipments);
                }
            });
            
            document.getElementById('prev-page')?.addEventListener('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    displayOrdersPage(allFilteredOrders, getOrderQuantityMap(allFilteredOrders), cachedShipments);
                }
            });
            
            document.getElementById('next-page')?.addEventListener('click', function() {
                const totalPages = Math.ceil(allFilteredOrders.length / ordersPerPage);
                if (currentPage < totalPages) {
                    currentPage++;
                    displayOrdersPage(allFilteredOrders, getOrderQuantityMap(allFilteredOrders), cachedShipments);
                }
            });
            
            document.getElementById('last-page')?.addEventListener('click', function() {
                const totalPages = Math.ceil(allFilteredOrders.length / ordersPerPage);
                if (currentPage !== totalPages) {
                    currentPage = totalPages;
                    displayOrdersPage(allFilteredOrders, getOrderQuantityMap(allFilteredOrders), cachedShipments);
                }
            });
            
            document.getElementById('page-size')?.addEventListener('change', function() {
                ordersPerPage = parseInt(this.value);
                currentPage = 1; // Reset to first page
                displayOrdersPage(allFilteredOrders, getOrderQuantityMap(allFilteredOrders), cachedShipments);
            });
        });
        
        // Helper function to get order quantity map
        function getOrderQuantityMap(orders) {
            const orderQuantityMap = {};
            
            orders.forEach(order => {
                const orderNumber = order.orderNumber;
                let totalQuantity = 0;
                
                order.items.forEach(item => {
                    totalQuantity += item.quantity || 1;
                });
                
                orderQuantityMap[orderNumber] = totalQuantity;
            });
            
            return orderQuantityMap;
        }
        
        // Modify any filter change handler to reset pagination
        function applyFilters() {
            currentPage = 1; // Reset to first page when filters change
            loadData();
        }
        
        // Function to collect profit data for all items
        function getAllProfitData(orders, orderQuantityMap, shipments) {
            const orderProfits = [];
            
            // If orderQuantityMap wasn't provided with the right structure, recalculate it
            if (!orderQuantityMap || Object.keys(orderQuantityMap).length === 0) {
                console.log("Recalculating orderQuantityMap in getAllProfitData");
                
                // Build a map of order numbers to all related orders (for parent-child)
                const relatedOrdersMap = {};
                
                // Group orders by orderNumber to handle parent-child relationships
                orders.forEach(order => {
                    const orderNumber = order.orderNumber;
                    if (!relatedOrdersMap[orderNumber]) {
                        relatedOrdersMap[orderNumber] = [];
                    }
                    relatedOrdersMap[orderNumber].push(order);
                });
                
                // Share shipping costs between parent and child orders
                Object.values(relatedOrdersMap).forEach(orderGroup => {
                    if (orderGroup.length > 1) {
                        // Find the parent order (usually the first one)
                        const parentOrder = orderGroup.find(order => 
                            order.advancedOptions && order.advancedOptions.mergedIds && 
                            order.advancedOptions.mergedIds.length > 0
                        ) || orderGroup[0];
                        
                        // Get parent shipping amount
                        const parentShippingAmount = parentOrder.shippingAmount || 0;
                        
                        // Distribute parent shipping to all orders in the group
                        orderGroup.forEach(order => {
                            if (order !== parentOrder && (!order.shippingAmount || order.shippingAmount === 0)) {
                                console.log(`In getAllProfitData: Transferring shipping cost from parent order ${parentOrder.orderNumber} to related order ${order.orderNumber}`);
                                order.shippingAmount = parentShippingAmount;
                            }
                        });
                    }
                });
                
                // Now calculate quantities
                Object.keys(relatedOrdersMap).forEach(orderNumber => {
                    let totalQuantity = 0;
                    
                    // Sum quantities across all related orders (parent and children)
                    relatedOrdersMap[orderNumber].forEach(order => {
                        order.items.forEach(item => {
                            totalQuantity += item.quantity || 1;
                        });
                    });
                    
                    orderQuantityMap[orderNumber] = totalQuantity;
                });
            }
            
            for (const order of orders) {
                const isSpecialOrder = order.orderNumber === "52698997";
                
                // Get store type
                const storeId = getStoreType(order);
                
                // Get label cost and shipping
                const totalLabelCost = getLabelCost(order.orderNumber, shipments);
                const totalCustomerPaidShipping = order.shippingAmount || 0;
                const orderTotalQuantity = orderQuantityMap[order.orderNumber] || 1;
                
                if (isSpecialOrder) {
                    console.log(`===== PROFIT CALCULATION FOR ${order.orderNumber} =====`);
                    console.log(`Order total quantity: ${orderTotalQuantity}`);
                    console.log(`Total label cost: $${totalLabelCost.toFixed(2)}`);
                    console.log(`Total customer paid shipping: $${totalCustomerPaidShipping.toFixed(2)}`);
                }
                
                // Calculate per unit shipping costs safely
                const { perUnitLabelCost, perUnitCustomerPaidShipping, isMultiLabelOrder } = calculatePerUnitShippingCosts(
                    totalLabelCost,
                    totalCustomerPaidShipping,
                    orderTotalQuantity,
                    order.orderNumber,
                    cachedShipments
                );
                
                if (isSpecialOrder) {
                    console.log(`Is multi-label order: ${isMultiLabelOrder}`);
                    console.log(`Per unit label cost: $${perUnitLabelCost.toFixed(2)}`);
                    console.log(`Per unit customer paid shipping: $${perUnitCustomerPaidShipping.toFixed(2)}`);
                    console.log(`Total items in order: ${order.items.length}`);
                }
                
                // Process each item in the order
                for (const item of order.items) {
                    const itemSku = item.sku || 'Unknown';
                    const itemQuantity = item.quantity || 1;
                    const sellingPrice = item.unitPrice * itemQuantity;
                    
                    // Calculate proportional shipping costs for this line item
                    let proportionalLabelCost = isMultiLabelOrder ? 
                        (perUnitLabelCost * itemQuantity) : // Use per-unit cost  quantity for multi-label
                        (perUnitLabelCost * itemQuantity); // Regular calculation
                    
                    let proportionalCustomerPaidShipping = isMultiLabelOrder ?
                        (perUnitCustomerPaidShipping * itemQuantity) : // Use per-unit cost  quantity for multi-label
                        (perUnitCustomerPaidShipping * itemQuantity); // Regular calculation
                    
                    // Find product cost and brand
                    const productInfo = findProductCost(item.sku);
                    const costPrice = productInfo.cost_price || 0;
                    
                    // Calculate profit and other metrics
                    const feePercentage = getPlatformFeePercentage(storeId);
                    const marketfee = parseFloat((sellingPrice * feePercentage).toFixed(2));
                    const total_cost_with_quantity = parseFloat((costPrice * itemQuantity).toFixed(2));
                    let Total_Cost = total_cost_with_quantity + marketfee + proportionalLabelCost;
                    let profit = (sellingPrice - Total_Cost) + proportionalCustomerPaidShipping;
                    
                    if (isSpecialOrder) {
                        console.log(`------ Item: ${itemSku} ------`);
                        console.log(`Item quantity: ${itemQuantity}`);
                        console.log(`Selling price: $${sellingPrice.toFixed(2)}`);
                        console.log(`Cost price: $${costPrice.toFixed(2)} per unit, total: $${total_cost_with_quantity.toFixed(2)}`);
                        console.log(`Proportional label cost: $${proportionalLabelCost.toFixed(2)}`);
                        console.log(`Proportional customer paid shipping: $${proportionalCustomerPaidShipping.toFixed(2)}`);
                        console.log(`Platform fee (${feePercentage}): $${marketfee.toFixed(2)}`);
                        console.log(`Total cost: $${Total_Cost.toFixed(2)}`);
                        console.log(`Final profit: $${profit.toFixed(2)}`);
                    }
                    
                    // Add to chart data
                    orderProfits.push({
                        orderNumber: order.orderNumber,
                        profit: profit,
                        store: storeId
                    });
                }
            }
            
            return orderProfits;
        }
        
        // Function to filter orders based on user selections (except brand)
        function preFilterOrders(orders) {
            if (!storeFilter || !statusFilter) {
                return orders;
            }
            
            const storeFilterValue = storeFilter.value;
            const orderStatus = statusFilter.value;
            const showMultiItemOnly = multiItemFilter ? multiItemFilter.checked : false;
            const showParentChildOnly = parentChildFilter ? parentChildFilter.checked : false;
            
            return orders.filter(order => {
                // Filter by store
                if (storeFilterValue !== 'all') {
                    const orderStoreId = getStoreType(order);
                    if (storeFilterValue !== orderStoreId) {
                        return false;
                    }
                }
                
                // Filter by status
                if (orderStatus !== 'all' && order.orderStatus !== orderStatus) {
                    return false;
                }
                
                // Filter by multi-item
                if (showMultiItemOnly && order.items.length < 2) {
                    return false;
                }
                
                // Filter by parent-child or multi-label orders
                if (showParentChildOnly) {
                    // Check for multi-label orders (orders with multiple shipments)
                    let isMultiLabelOrder = false;
                    if (cachedShipments && Array.isArray(cachedShipments)) {
                        const orderShipments = cachedShipments.filter(shipment => 
                            shipment.orderNumber === order.orderNumber);
                        isMultiLabelOrder = orderShipments.length > 1;
                    }
                    
                    // Check for parent-child relationships
                    const hasParentChildRelation = order.advancedOptions && 
                        (order.advancedOptions.parentId || 
                        (order.advancedOptions.mergedIds && 
                         order.advancedOptions.mergedIds.length > 0));
                    
                    // If neither multi-label nor parent-child, filter it out
                    if (!isMultiLabelOrder && !hasParentChildRelation) {
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        // Function to apply brand filter
        function applyBrandFilter(orders) {
            if (!brandFilter || brandFilter.value === 'all') {
                return orders;
            }
            
            const brandFilterValue = brandFilter.value.toLowerCase();
            
            return orders.filter(order => {
                // Check if any item in the order has the selected brand
                return order.items.some(item => {
                    const productInfo = findProductCost(item.sku);
                    const brand = productInfo.manufacturer || '';
                    return brand && brand.toLowerCase() === brandFilterValue;
                });
            });
        }
        
        // Function to populate the brand filter with unique brands from filtered orders
        function populateBrandFilter(filteredOrders) {
            if (!brandFilter) return Promise.resolve();
            
            try {
                // Save current selection
                const currentSelection = brandFilter.value;
                
                // Clear existing options except the first one (All Brands)
                while (brandFilter.options.length > 1) {
                    brandFilter.remove(1);
                }
                
                // If no filtered orders provided, use the full product list from API
                if (!filteredOrders || !Array.isArray(filteredOrders) || filteredOrders.length === 0) {
                    if (window.cachedProductsData && Array.isArray(window.cachedProductsData)) {
                        const manufacturersSet = new Set();
                        
                        // Extract all manufacturers from API data
                        window.cachedProductsData.forEach(product => {
                            if (product && product.Manufacturer && product.Manufacturer !== 'Unknown') {
                                manufacturersSet.add(product.Manufacturer);
                            }
                        });
                        
                        const manufacturers = Array.from(manufacturersSet).sort();
                        console.log(`Found ${manufacturers.length} unique manufacturers from all products`);
                        
                        // Add manufacturer options
                        manufacturers.forEach(manufacturer => {
                            if (!manufacturer) return; // Skip empty values
                            const option = document.createElement('option');
                            option.value = manufacturer;
                            option.textContent = manufacturer;
                            brandFilter.appendChild(option);
                        });
                        
                        // Restore previous selection if it exists in the new options
                        if (currentSelection !== 'all') {
                            let found = false;
                            for (let i = 0; i < brandFilter.options.length; i++) {
                                if (brandFilter.options[i].value === currentSelection) {
                                    brandFilter.selectedIndex = i;
                                    found = true;
                                    break;
                                }
                            }
                            // If previously selected brand not in new list, reset to "All Brands"
                            if (!found) {
                                brandFilter.selectedIndex = 0;
                            }
                        }
                        
                        return Promise.resolve();
                    }
                }
                
                // Extract unique manufacturers from the filtered orders
                const manufacturersSet = new Set();
                
                // Process each order's items to find unique manufacturers
                filteredOrders.forEach(order => {
                    if (order && Array.isArray(order.items)) {
                        order.items.forEach(item => {
                            const productInfo = findProductCost(item.sku);
                            const manufacturer = productInfo.manufacturer;
                            if (manufacturer && manufacturer !== 'Unknown') {
                                manufacturersSet.add(manufacturer);
                }
            });
        }
                });
                
                const manufacturers = Array.from(manufacturersSet).sort();
                console.log(`Found ${manufacturers.length} unique manufacturers in filtered orders`);
                
                // Add manufacturer options
                manufacturers.forEach(manufacturer => {
                    if (!manufacturer) return; // Skip empty values
                    const option = document.createElement('option');
                    option.value = manufacturer;
                    option.textContent = manufacturer;
                    brandFilter.appendChild(option);
                });
                
                // Restore previous selection if it exists in the new options
                if (currentSelection !== 'all') {
                    let found = false;
                    for (let i = 0; i < brandFilter.options.length; i++) {
                        if (brandFilter.options[i].value === currentSelection) {
                            brandFilter.selectedIndex = i;
                            found = true;
                            break;
                        }
                    }
                    // If previously selected brand not in new list, reset to "All Brands"
                    if (!found) {
                        brandFilter.selectedIndex = 0;
                    }
                }
                
                return Promise.resolve();
            } catch (error) {
                console.error('Error populating brand filter:', error);
                return Promise.reject(error);
            }
        }
        
        // Function to load data with safety checks
        function loadData() {
            // Prevent multiple concurrent API calls
            if (isLoading) {
                    return;
                }
            
            try {
                showLoading(true, 'Loading orders and shipments data');
                
                const tableBody = document.getElementById("shipstation-table");
                if (tableBody) {
                    tableBody.innerHTML = `<tr><td colspan="12" style="text-align:center;">Fetching orders, please wait...</td></tr>`;
                }
                
                // Get date range based on user selection
                const { startDate, endDate } = getDateRange();
                const cacheKey = getCacheKeyForCurrentDateRange();
                
                // Force clear cache for this date range to ensure fresh data
                try {
                    localStorage.removeItem(`shipstation_cache_${cacheKey}`);
                } catch (e) {
                    // Ignore storage errors
                }
                
                // Reset cached data to force reload
                cachedOrders = [];
                cachedShipments = [];
                
                // Load both orders and shipments concurrently
                const ordersPromise = fetchShipStationOrders(startDate, endDate)
                    .then(orders => {
                        if (!orders || !Array.isArray(orders)) {
                            throw new Error('Invalid orders data received');
                        }
                
                // Store in global cache
                        cachedOrders = orders;
                        console.log(`Loaded ${cachedOrders.length} orders for date range ${startDate} to ${endDate}`);
                
                        // Try to cache, but handle quota errors gracefully
                try {
                    localStorage.setItem(`shipstation_cache_${cacheKey}`, JSON.stringify(orders));
                } catch (e) {
                            console.warn('Could not cache orders data due to quota limits. This is non-critical.');
                        }
                        
                        return orders;
                    })
                    .catch(error => {
                        console.error('Error loading orders:', error);
                        showError('Failed to load order data. Please try again.');
                        return [];
                    });
                
                const shipmentsPromise = fetchShipStationShipments(startDate, endDate)
                    .then(shipments => {
                        if (!shipments || !Array.isArray(shipments)) {
                            return [];
                        }
                        cachedShipments = shipments;
                        return shipments;
                    })
                    .catch(error => {
                        console.error('Error loading shipments:', error);
                        // Non-critical, can continue without shipments
                        return [];
                    });
                
                // Wait for both to complete
                Promise.all([ordersPromise, shipmentsPromise])
                    .then(([orders, shipments]) => {
                        console.log('All data loaded successfully, displaying results...');
                
                if (orders && orders.length > 0) {
                            // Reset pagination when new data is loaded
                            currentPage = 1;
                            ordersPerPage = 100;
                            
                            // Pre-process orders with shipment data for faster filtering later
                            return preprocessOrders(orders, shipments)
                                .then(processed => {
                                    processedOrders = processed;
                                    displayOrders(orders);
                                });
                } else {
                    const tableBody = document.getElementById("shipstation-table");
                    if (tableBody) {
                        tableBody.innerHTML = `<tr><td colspan="12" style="color:orange;">No orders found for the selected date range</td></tr>`;
                    }
                            updateStatistics([]);
                            updatePaginationInfo(0, 0, 0);
                }
                    })
                    .catch(error => {
                showLoading(false);
                        console.error('Error processing data:', error);
                        showError('Failed to process order data. Please try again.');
                    })
                    .finally(() => {
                        showLoading(false);
                    });
            } catch (error) {
                showLoading(false);
                console.error('Error in loadData:', error);
                showError('An unexpected error occurred. Please try again.');
            }
        }
        
        // Preprocess orders with shipment data once
        async function preprocessOrders(orders, shipments) {
            const processed = [];
            
            // First, calculate total quantities per order to properly distribute shipping costs
            const orderQuantityMap = {};
            
            // Step 1: Get total quantity for each order
            orders.forEach(order => {
                const orderNumber = order.orderNumber;
                let totalQuantity = 0;
                
                order.items.forEach(item => {
                    totalQuantity += item.quantity || 1;
                });
                
                orderQuantityMap[orderNumber] = totalQuantity;
            });
            
            for (const order of orders) {
                // Get store type for display
                const storeId = getStoreType(order);
                const storeBadge = getStoreBadge(storeId);
                const isMultiItemOrder = order.items.length > 1;
                
                // Get label cost for the order using the shipments data
                const totalLabelCost = getLabelCost(order.orderNumber, shipments);
                
                // Get customer paid shipping amount
                const totalCustomerPaidShipping = order.shippingAmount || 0;
                
                // Get the total quantity for this order for proportional distribution
                const orderTotalQuantity = orderQuantityMap[order.orderNumber];
                
                // Calculate per unit shipping costs
                const perUnitLabelCost = totalLabelCost / orderTotalQuantity;
                const perUnitCustomerPaidShipping = totalCustomerPaidShipping / orderTotalQuantity;
                
                // Process each item 
                for (let itemIndex = 0; itemIndex < order.items.length; itemIndex++) {
                    const item = order.items[itemIndex];
                    const itemQuantity = item.quantity || 1;
                    const sellingPrice = item.unitPrice * itemQuantity;
                    
                    // Calculate proportional shipping costs for this line item
                    const proportionalLabelCost = perUnitLabelCost * itemQuantity;
                    const proportionalCustomerPaidShipping = perUnitCustomerPaidShipping * itemQuantity;
                    
                    // Find product cost and brand - now use await
                    const productInfo = findProductCost(item.sku);
                    const costPrice = productInfo.cost_price || 0;
                    const manufacturer = productInfo.manufacturer || 'Unknown';
                    
                    // Calculate profit and other metrics
                    const feePercentage = getPlatformFeePercentage(storeId);
                    const marketfee = parseFloat((sellingPrice * feePercentage).toFixed(2));
                    const feeDisplay = `${(feePercentage * 100).toFixed(0)}%`;
                    const total_cost_with_quantity = parseFloat((costPrice * itemQuantity).toFixed(2));
                    let Total_Cost = total_cost_with_quantity + marketfee + proportionalLabelCost;
                    let profit = (sellingPrice - Total_Cost) + proportionalCustomerPaidShipping;
                    
                    // Store processed data
                    processed.push({
                        order,
                        item,
                        itemIndex,
                        storeId,
                        storeBadge,
                        isMultiItemOrder,
                        sellingPrice,
                        costPrice,
                        itemQuantity,
                        marketfee,
                        manufacturer,
                        proportionalLabelCost,
                        totalLabelCost,
                        perUnitLabelCost,
                        total_cost_with_quantity,
                        Total_Cost,
                        profit,
                        proportionalCustomerPaidShipping,
                        totalCustomerPaidShipping,
                        perUnitCustomerPaidShipping,
                        feePercentage,
                        feeDisplay,
                        orderTotalQuantity
                    });
                }
            }
            
            return processed;
        }
        
        // Format data for chart - adjust store IDs to store names
        function storeIdToName(storeId) {
            switch(storeId) {
                case "373980": return "SurgiMac Amazon";
                case "498468": return "SurgiMac eBay";
                case "470756": return "DD eBay";
                case "428642": return "Dental District";
                case "331737": return "Manual Orders";
                case "452424": return "Network";
                case "498364": return "Walmart";
                case "498515": return "Supply District";
                case "494346": return "SurgiMac";
                default: return "Network"; // Default to Network instead of "Other"
            }
        }

        // Simple chart creation function - basic implementation for reliability
        function createProfitChart(orderProfits) {
            const chartCanvas = document.getElementById('profit-chart');
            if (!chartCanvas) return;
            
            // Clear any existing chart
            if (profitChart) {
                profitChart.destroy();
            }
            
            // Group data by store
            const storeData = {};
            
            orderProfits.forEach(item => {
                const storeId = item.store || 'other';
                const storeName = storeIdToName(storeId);
                
                if (!storeData[storeName]) {
                    storeData[storeName] = {
                        totalProfit: 0,
                        count: 0,
                        storeId: storeId
                    };
                }
                storeData[storeName].totalProfit += item.profit;
                storeData[storeName].count++;
            });
            
            // Prepare data for chart
            const labels = Object.keys(storeData);
            const data = labels.map(store => storeData[store].totalProfit);
            const counts = labels.map(store => storeData[store].count);
            
            // Colors for different stores
            const colors = {
                "SurgiMac Amazon": 'rgba(255, 153, 0, 0.7)',
                "SurgiMac eBay": 'rgba(229, 50, 56, 0.7)',
                "DD eBay": 'rgba(147, 112, 219, 0.7)',
                "Dental District": 'rgba(60, 179, 113, 0.7)',
                "Manual Orders": 'rgba(32, 178, 170, 0.7)',
                "Network": 'rgba(70, 130, 180, 0.7)',
                "Walmart": 'rgba(0, 113, 206, 0.7)',
                "Supply District": 'rgba(255, 99, 71, 0.7)',
                "SurgiMac": 'rgba(106, 90, 205, 0.7)'
            };
            
            const backgroundColors = labels.map(label => 
                colors[label] || (
                    storeData[label].totalProfit >= 0 ? 
                    'rgba(92, 196, 107, 0.7)' : 
                    'rgba(255, 107, 107, 0.7)'
                )
            );
            
            // Format labels to show count
            const formattedLabels = labels.map(label => 
                `${label} (${storeData[label].count} orders)`
            );
            
            // Create chart
            profitChart = new Chart(chartCanvas, {
                type: 'bar',
                data: {
                    labels: formattedLabels,
                    datasets: [{
                        label: 'Total Profit by Store ($)',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors.map(color => color.replace('0.7', '1')),
                        borderWidth: 1
                    }]
                },
                options: {
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#ffffff'
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                color: '#ffffff'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        }
                    }
                }
            });
        }
        
        // Get a cache key for the current date range
        function getCacheKeyForCurrentDateRange() {
            const { startDate, endDate } = getDateRange();
            return `orders_${startDate.substring(0, 10)}_${endDate.substring(0, 10)}`;
        }

        // Add a function to determine the platform fee percentage based on store
        function getPlatformFeePercentage(storeId) {
            switch(storeId) {
                case "452424": // Network (Net32)
                    return 0.18; // 18%
                case "373980": // SurgiMac Amazon Store
                    return 0.15; // 15%
                default:
                    return 0.15; // 15% for all other stores
            }
        }

        // Add the event listeners for filter changes back
        // Event listeners for filter changes
        if (storeFilter) {
            storeFilter.addEventListener('change', function() {
                // If we have orders, just refresh the display with the new filter
                if (cachedOrders && cachedOrders.length > 0) {
                    displayOrders(cachedOrders);
                } else {
                    // If no orders, load data
                    loadData();
                }
            });
        }
        
        if (statusFilter) {
            statusFilter.addEventListener('change', function() {
                if (cachedOrders && cachedOrders.length > 0) {
                    displayOrders(cachedOrders);
                } else {
                    loadData();
                }
            });
        }
        
        if (brandFilter) {
            brandFilter.addEventListener('change', function() {
                if (cachedOrders && cachedOrders.length > 0) {
                    displayOrders(cachedOrders);
                } else {
                    loadData();
                }
            });
        }
        
        if (multiItemFilter) {
            multiItemFilter.addEventListener('change', function() {
                if (cachedOrders && cachedOrders.length > 0) {
                    displayOrders(cachedOrders);
                    } else {
                    loadData();
                }
            });
        }
        
        if (parentChildFilter) {
            parentChildFilter.addEventListener('change', function() {
                if (cachedOrders && cachedOrders.length > 0) {
                    displayOrders(cachedOrders);
                } else {
                    loadData();
                }
            });
        }
        
        // Function to check if cache is valid (simplified version of the one in shipstation-api.js)
        function isLocalCacheValid(cacheKey) {
            try {
                const cacheData = localStorage.getItem(`shipstation_cache_${cacheKey}`);
                return !!cacheData;
                } catch (error) {
                return false;
            }
        }
        
        // Add this new function to show temporary error messages
        function showError(message, duration = 5000) {
            // Create error message element if it doesn't exist
            let errorEl = document.getElementById('error-message');
            if (!errorEl) {
                errorEl = document.createElement('div');
                errorEl.id = 'error-message';
                errorEl.style.cssText = 'position: fixed; top: 20px; right: 20px; background-color: #f8d7da; color: #721c24; ' +
                                       'padding: 15px; border-radius: 5px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); ' +
                                       'z-index: 9999; max-width: 350px; text-align: center;';
                document.body.appendChild(errorEl);
            }
            
            // Set message and show
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            
            // Hide after duration
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, duration);
        }

        // Function to fetch products directly from API without merging with Net32 data
        async function fetchDirectProductsFromAPI() {
            try {
                // Check local storage cache first
                const cachedData = localStorage.getItem('api_products_cache');
                if (cachedData) {
                    const { timestamp, data } = JSON.parse(cachedData);
                    // Check if cache is less than 1 hour old
                    if (timestamp && (Date.now() - timestamp < 60 * 60 * 1000)) {
                        console.log('Using cached API products data');
                        return data;
                    }
                }
                
                // Use the same API URL as in Brands.js
                const apiUrl = 'https://backend-api-4679.onrender.com/api/products';
                console.log('Fetching products directly from API:', apiUrl);
                
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`API request failed: ${response.status}`);
                }
                
                const products = await response.json();
                console.log(`Received ${products.length} products from API`);
                
                // Cache the results
                try {
                    localStorage.setItem('api_products_cache', JSON.stringify({
                        timestamp: Date.now(),
                        data: products
                    }));
                } catch (e) {
                    console.warn('Could not cache products due to quota limits', e);
                }
                
                return products;
            } catch (error) {
                console.error('Error fetching products from API:', error);
                // Return empty array on error
                return [];
            }
        }

        // Add event listener for CSV export button
        const exportCsvBtn = document.getElementById('export-csv');
        if (exportCsvBtn) {
            exportCsvBtn.addEventListener('click', function() {
                exportToCSV(); // Use our new function with customer information
            });
        }
        
        // Function to export table data to CSV
        function exportTableToCSV(filename) {
            if (!cachedOrders || cachedOrders.length === 0) {
                showError('No data available to export');
                return;
            }
            
            // First, prefilter by store, status, multi-item
            const preFilteredOrders = preFilterOrders(cachedOrders);
            
            // Then apply brand filter
            const filteredOrders = applyBrandFilter(preFilteredOrders);
            
            if (filteredOrders.length === 0) {
                showError('No data matches current filters to export');
                return;
            }
            
            // Create CSV header row
            const headers = [
                'Store', 'Order Number', 'Order Status', 'Order Date', 
                'SKU', 'Manufacturer', 'Description', 'Selling Price ($)', 
                'Cost Price ($)', 'Quantity', 'Platform Fee', 'Cost W/ Quantity',
                'Label Cost ($)', 'Total Cost ($)', 'P/L($)', 'Heavy Shipping($)',
                'Customer Name', 'Address 1', 'City', 'State', 'Zipcode', 'Country'
            ];
            
            let csvContent = headers.join(',') + '\n';
            
            const orderQuantityMap = {};
            
            // First calculate total quantities per order for shipping cost distribution
            filteredOrders.forEach(order => {
                let totalQuantity = 0;
                order.items.forEach(item => {
                    totalQuantity += (item.quantity || 1);
                });
                orderQuantityMap[order.orderNumber] = totalQuantity || 1;
            });
            
            // Generate CSV rows
            filteredOrders.forEach(order => {
                // Get total shipping costs for this order
                const totalLabelCost = getLabelCost(order.orderNumber, cachedShipments);
                const totalCustomerPaidShipping = order.shippingAmount || 0;
                
                // Get the total quantity for this order for proportional distribution
                const orderTotalQuantity = orderQuantityMap[order.orderNumber] || 1;
                
                // Calculate per unit shipping costs safely
                const { perUnitLabelCost, perUnitCustomerPaidShipping, isMultiLabelOrder } = calculatePerUnitShippingCosts(
                    totalLabelCost,
                    totalCustomerPaidShipping,
                    orderTotalQuantity,
                    order.orderNumber,
                    cachedShipments
                );
                
                // Get store type
                const storeId = getStoreType(order);
                const storeName = storeIdToName(storeId);
                
                // Extract customer information
                const customer = order.shipTo || {};
                const customerName = customer.name || "N/A";
                const customerAddress1 = customer.street1 || "N/A";
                const customerCity = customer.city || "N/A";
                const customerState = customer.state || "N/A";
                const customerZipCode = customer.postalCode || "N/A";
                const customerCountry = customer.country || "N/A";
                
                // Process each item in the order
                order.items.forEach(item => {
                    const itemQuantity = item.quantity || 1;
                    const sellingPrice = item.unitPrice * itemQuantity;
                    
                    // Calculate proportional shipping costs for this line item
                    const proportionalLabelCost = isMultiLabelOrder ? 
                        (perUnitLabelCost / order.items.length) : // Distribute evenly across all items
                        (perUnitLabelCost * itemQuantity); // Regular calculation
                    
                    const proportionalCustomerPaidShipping = isMultiLabelOrder ?
                        (perUnitCustomerPaidShipping / order.items.length) : // Distribute evenly
                        (perUnitCustomerPaidShipping * itemQuantity); // Regular calculation
                    
                    // Find product cost and brand
                    const productInfo = findProductCost(item.sku);
                    const costPrice = productInfo.cost_price || 0;
                    const manufacturer = productInfo.manufacturer || 'Unknown';
                    
                    // Calculate profit and other metrics
                    const feePercentage = getPlatformFeePercentage(storeId);
                    const marketfee = parseFloat((sellingPrice * feePercentage).toFixed(2));
                    const total_cost_with_quantity = parseFloat((costPrice * itemQuantity).toFixed(2));
                    let Total_Cost = total_cost_with_quantity + marketfee + proportionalLabelCost;
                    let profit = (sellingPrice - Total_Cost) + proportionalCustomerPaidShipping;
                    
                    // Escape function for CSV values
                    const escapeCsv = (val) => {
                        if (val === null || val === undefined) return '';
                        val = String(val);
                        // Wrap in quotes and escape internal quotes if the value contains commas, quotes or newlines
                        if (val.includes(',') || val.includes('"') || val.includes('\n')) {
                            return `"${val.replace(/"/g, '""')}"`;
                        }
                        return val;
                    };
                    
                    // Format for CSV (escape commas and quotes)
                    const csvRow = [
                        escapeCsv(storeName),
                        escapeCsv(order.orderNumber || 'N/A'),
                        escapeCsv(order.orderStatus || 'N/A'),
                        escapeCsv(new Date(order.createDate).toLocaleString('en-US', {timeZone: 'America/New_York'})),
                        escapeCsv(item.sku || 'N/A'),
                        escapeCsv(manufacturer),
                        escapeCsv(item.name || 'N/A'),
                        sellingPrice.toFixed(2),
                        costPrice.toFixed(2),
                        itemQuantity,
                        marketfee.toFixed(2),
                        total_cost_with_quantity.toFixed(2),
                        proportionalLabelCost.toFixed(2),
                        Total_Cost.toFixed(2),
                        profit.toFixed(2),
                        proportionalCustomerPaidShipping.toFixed(2),
                        escapeCsv(customerName),
                        escapeCsv(customerAddress1),
                        escapeCsv(customerCity),
                        escapeCsv(customerState),
                        escapeCsv(customerZipCode),
                        escapeCsv(customerCountry)
                    ];
                    
                    csvContent += csvRow.join(",") + "\n";
                });
            });

            // Download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const fileDate = new Date().toISOString().slice(0, 10);
            const link = document.createElement("a");
            
            // Check if browser supports download attribute
            if (navigator.msSaveBlob) { // IE 10+
                navigator.msSaveBlob(blob, `shipstation_orders_${fileDate}.csv`);
            } else {
                const url = URL.createObjectURL(blob);
                link.setAttribute("href", url);
                link.setAttribute("download", `shipstation_orders_${fileDate}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Function to export data to CSV
        function exportToCSV() {
            // Get current date for the filename
            const fileDate = new Date().toISOString().slice(0, 10);
            const filename = `shipstation_orders_${fileDate}.csv`;
            
            // Use the exportTableToCSV function with our filename
            exportTableToCSV(filename);
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
</body>
</html>
